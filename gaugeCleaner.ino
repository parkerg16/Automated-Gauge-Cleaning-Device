#include <Servo.h> // Servo Library
#include <ESP8266WiFi.h> // WiFi Libraries
#include <ESP8266WebServer.h> // WiFi Libraries
#include <Adafruit_GFX.h> // Oled Libraries
#include <Adafruit_SSD1306.h> // Oled Libraries 


#define SCREEN_WIDTH 128  // OLED display width, in pixels
#define SCREEN_HEIGHT 64  // OLED display height, in pixels


// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET -1  // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);


#define greenButton D0
//oled pin 1 = D1
//oled pin 2 = D2
#define leftServoPin D3 // Blue
#define rightServoPin D4// Green
//3.3V
//G
#define rotarySwitch D5
#define outputB D6
#define outputA D7
#define piezoBuzzer D8



// Inititalize Global Variables and constants
int leftServoPosition;
int rightServoPosition;
int leftOpenTime = 5000;
int rightOpenTime = 5000;
int leftClosedTime = 5000;
int cleanTime = 6000;
int cycleCount = 0;
int beginTime = 0;
bool greenButtonState = false;

unsigned long lastImageChangeTime = 0;  // Track the time of the last image change
const unsigned long imageChangeInterval = 1000;  // Interval between image changes (in milliseconds)
//Create servo objects
Servo leftServo;
Servo rightServo;

//Create server object on port 80
ESP8266WebServer server(80);




// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 1040)
const int epd_bitmap_allArray_LEN = 1;
const unsigned char* epd_bitmap_allArray[1] = {
  epd_bitmap_128x64_Template
};

// '128x64 Template Green To Begin', 128x64px
const unsigned char epd_bitmap_128x64_Template_Green_To_Begin [] PROGMEM = {
0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x03, 0xf0, 0x00, 0x02, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x06, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x20, 0x1e, 0x7c, 0x7c, 0xfc, 0x06, 0x1f, 0x06, 0x13, 0xf3, 0xf2, 0x3e, 0x00, 0x01, 
	0x80, 0x00, 0x27, 0x30, 0xc4, 0xc4, 0x84, 0x06, 0x31, 0x87, 0xf2, 0x12, 0x12, 0x22, 0x00, 0x01, 
	0x80, 0x00, 0x20, 0x90, 0xfc, 0xfc, 0x84, 0x06, 0x20, 0x87, 0xf3, 0xf2, 0x12, 0x22, 0x00, 0x01, 
	0x80, 0x00, 0x20, 0x90, 0x80, 0x80, 0x84, 0x06, 0x20, 0x86, 0x12, 0x02, 0x12, 0x22, 0x00, 0x01, 
	0x80, 0x00, 0x21, 0x90, 0x80, 0x80, 0x84, 0x06, 0x31, 0x86, 0x12, 0x03, 0xf2, 0x22, 0x00, 0x01, 
	0x80, 0x00, 0x1f, 0x10, 0xfc, 0xfc, 0x84, 0x06, 0x1f, 0x07, 0xf3, 0xf0, 0x12, 0x22, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x1f, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0x01, 0xf0, 0x01, 
	0x80, 0x00, 0x00, 0x7f, 0xe0, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x03, 0xff, 0xff, 0x83, 0xf0, 0x01, 
	0x80, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x3f, 0xff, 0xff, 0x80, 0x0f, 0xff, 0xff, 0x83, 0xf0, 0x01, 
	0x80, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x3f, 0xff, 0xff, 0xc0, 0x1f, 0xff, 0xff, 0x83, 0xf0, 0x01, 
	0x80, 0x00, 0x01, 0xff, 0xf8, 0x00, 0x3f, 0xff, 0xff, 0xc0, 0x3f, 0xff, 0xff, 0x83, 0xf0, 0x01, 
	0x80, 0x00, 0x01, 0xf9, 0xf8, 0x00, 0x1f, 0xff, 0xff, 0xe0, 0x3f, 0xff, 0xff, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x01, 0xf8, 0xfc, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x7f, 0x80, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x03, 0xf0, 0xfc, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x7e, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x03, 0xf0, 0xfc, 0x00, 0x00, 0x00, 0x03, 0xf0, 0xfc, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x07, 0xe0, 0x7e, 0x00, 0x00, 0x00, 0x03, 0xf0, 0xfc, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x07, 0xe0, 0x7e, 0x00, 0x00, 0x00, 0x03, 0xe0, 0xf8, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x07, 0xe0, 0x7f, 0x00, 0x00, 0x00, 0x03, 0xe0, 0xf8, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x0f, 0xc0, 0x3f, 0x00, 0x00, 0x00, 0x07, 0xe1, 0xf8, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x0f, 0xc0, 0x3f, 0x00, 0x03, 0xff, 0xff, 0xe1, 0xf8, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x1f, 0x80, 0x1f, 0x80, 0x0f, 0xff, 0xff, 0xc1, 0xf8, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x1f, 0x80, 0x1f, 0x80, 0x1f, 0xff, 0xff, 0x81, 0xf8, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x1f, 0x80, 0x1f, 0x80, 0x1f, 0xff, 0xff, 0x01, 0xf8, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x3f, 0x00, 0x0f, 0xc0, 0x1f, 0xff, 0xfe, 0x01, 0xf8, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x3f, 0x00, 0x0f, 0xc0, 0x1f, 0xff, 0xf8, 0x00, 0xf8, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x7e, 0x00, 0x0f, 0xe0, 0x1f, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x7e, 0x00, 0x07, 0xe0, 0x1f, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0x7e, 0x00, 0x07, 0xe0, 0x1f, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0xfc, 0x00, 0x03, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x00, 0xfc, 0x00, 0x03, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x01, 0xfc, 0x00, 0x03, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x03, 0xf0, 0x01, 
	0x80, 0x01, 0xf8, 0x00, 0x01, 0xf8, 0x1f, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x83, 0xf0, 0x01, 
	0x80, 0x01, 0xf8, 0x00, 0x01, 0xf8, 0x1f, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0x83, 0xf0, 0x01, 
	0x80, 0x03, 0xf0, 0x00, 0x01, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x83, 0xf0, 0x01, 
	0x80, 0x03, 0xf0, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0x83, 0xf0, 0x01, 
	0x80, 0x07, 0xf0, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x83, 0xf0, 0x01, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 1040)
const int epd_bitmap_allArray_LEN1 = 1;
const unsigned char* epd_bitmap_allArray1[1] = {
	epd_bitmap_128x64_Template_Green_To_Begin
};



void setup() {
  pinMode(piezoBuzzer, OUTPUT);
  pinMode(greenButton, INPUT_PULLUP);
  delay(150);


  //Create wifi access point with SSID APCI Gauge Cleaner
  WiFi.softAP("APCI Gauge Cleaner", "Gotocitra");
  IPAddress IP = WiFi.softAPIP();


  //Initialize Oled Display
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.clearDisplay();
  display.drawBitmap(0, 0, epd_bitmap_128x64_Template, 128, 64, WHITE);
  lastImageChangeTime = millis();
  display.display();
 

  //Begin serial on baud rate 9600
  Serial.begin(9600);
  delay(250);

  //Print IP address to serial monitor
  Serial.print("AP IP address: ");
  Serial.println(IP);
  Serial.println(greenButtonState);

  //Set servo position before it is turned on
  moveServo(leftServo, 190);
  moveServo(rightServo, 0);
  leftServo.attach(leftServoPin);
  rightServo.attach(rightServoPin);
  //Allow time for server to set positon
  delay(150);
  
}


void moveServo(Servo& servo, int angle) {
  const float microSecondsPerDegree = 2000 / 270;  // 7.4 microseconds per degree
  float totalMicroseconds = (angle * microSecondsPerDegree) + 500;
  servo.writeMicroseconds(totalMicroseconds);
  Serial.println(totalMicroseconds);
}


void openRightServo() {
  rightServo.attach(rightServoPin);
  moveServo(rightServo, 0);
  Serial.println("Right Side Opened");
  int seconds = 0;
  int minutes = 0;

  // Detach to reduce heat
  leftServo.detach();
}


void openLeftServo() {
  leftServo.attach(leftServoPin);
  moveServo(leftServo, 190);
  Serial.println("Left Side Opened");
  int seconds = 0;
  int minutes = 0;


  leftServo.detach(); // Detach to reduce heat
}


void closeLeftServo() {
  leftServo.attach(leftServoPin);
  moveServo(leftServo, 0);
  Serial.println("Left Side Closed");
  int seconds = 0;
  int minutes = 0;


  
  leftServo.detach(); // Detach to reduce heat
}


void closeRightServo() {
  rightServo.attach(rightServoPin);
  moveServo(rightServo, 190);
  Serial.println("Right Side Closed");
  int seconds = 0;
  int minutes = 0;


  leftServo.detach(); // Detach to reduce heat
}

unsigned long updateScreenAndDelay(unsigned long stepStartTime, unsigned long delayTime) {
  unsigned long currentStepTime = millis() - stepStartTime;

  while (currentStepTime < delayTime) {
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(WHITE);  // Draw white text
    display.setCursor(0, 0);      // Start at top-left corner
    display.print((currentStepTime / 1000));
    display.println(F(" seconds"));
    display.setTextSize(1);  // Normal 1:1 pixel scale
    display.print(F("Cycle count:"));
    display.println(cycleCount);
    int seconds = ((millis() - beginTime) / 1000) % 60;
    int minutes = ((millis() - beginTime) / 1000) / 60;
    display.print(minutes);
    display.print(F(" Minutes "));
    display.print(seconds);
    display.print(F(" Seconds"));
    display.display();

    delay(20);  // Delay for 20ms for better accuracy
    currentStepTime = millis() - stepStartTime;  // Update the current step time
  }

  return currentStepTime;
}


void cleanGauge() {
  // Left Servo goes to OUTPUT flask
  // Right Servo Pulls from INPUT flask and gauge

  // Servos are closed on boot, but reclosed here for Redundancy
  closeRightServo();
  closeLeftServo();

  openLeftServo();
  unsigned long stepStartTime = millis();  // Store the start time for each step
  unsigned long currentStepTime = 0;  // Track the current step time

  // Step 1: Update screen and delay
  currentStepTime += updateScreenAndDelay(stepStartTime + currentStepTime, 750);

  // Step 2: Update screen and delay
  currentStepTime += updateScreenAndDelay(stepStartTime + currentStepTime, 4250);
  // Gauge should be under vacuum now
  closeLeftServo();

  // Step 3: Update screen and delay
  currentStepTime += updateScreenAndDelay(stepStartTime + currentStepTime, 750);
  // Gauge locked in vacuum now
  openRightServo();

  // Step 4: Update screen and delay
  currentStepTime += updateScreenAndDelay(stepStartTime + currentStepTime, 3250);
  // Gauge fills with HFE
  closeRightServo();

  // Step 5: Update screen and delay
  currentStepTime += updateScreenAndDelay(stepStartTime + currentStepTime, 750);
  cycleCount++;

  tone(piezoBuzzer, 2000);

  // Step 6: Update screen and delay
  currentStepTime += updateScreenAndDelay(stepStartTime + currentStepTime, 100);
  noTone(piezoBuzzer);

  Serial.print(F("Total time: "));
  Serial.print(currentStepTime / 1000.0);
  Serial.println(F(" seconds"));

  greenButtonState = false;
}


void rotaryEncoder() {
  //Rotary Encoder Setup


  int counter = 0;
  int currentStateA;
  int lastStateA;
  String currentDir = "";


  pinMode(rotarySwitch, INPUT);
  pinMode(outputA, INPUT);
  pinMode(outputB, INPUT);


  lastStateA = digitalRead(outputA);
  //Rotary Encoder Setup Finish


  // Read the current state of outputA
  currentStateA = digitalRead(outputA);


  // If last and current state of outputA are different, then pulse occurred
  // React to only 1 state change to avoid double count
  if (currentStateA != lastStateA && currentStateA == 1) {

    // If the outputB state is different than the outputA state then
    // the encoder is rotating CCW so decrement
    if (digitalRead(outputB) != currentStateA) {
      counter++;
      currentDir = "CW";
    } else {
      // Encoder is rotating CW so increment
      counter--;
      currentDir = "ACW";
    }

    Serial.print("Direction: ");
    Serial.print(currentDir);
    Serial.print(" | Counter: ");
    Serial.println(counter);
  }

  // Remember last outputA state
  lastStateA = currentStateA;

  // Put in a slight delay to help debounce the reading
  delay(1);
}



bool showImage1 = true;  // Flag to keep track of the current image state

void loop() {
  unsigned long currentTime = millis();
  if (currentTime - lastImageChangeTime >= imageChangeInterval) {
    // Toggle the image state
    showImage1 = !showImage1;
    // Update the display with the new image
    display.clearDisplay();
    display.setCursor(0, 0);
    if (showImage1) {
      display.drawBitmap(0, 0, epd_bitmap_128x64_Template_Green_To_Begin, 128, 64, WHITE);
    } else {
      display.drawBitmap(0, 0, epd_bitmap_128x64_Template, 128, 64, WHITE);
    }
    display.display();
    // Reset the image change time
    lastImageChangeTime = currentTime;
  }

  if (digitalRead(greenButton) == LOW) {
    // Debounce the button
    delay(10);
    if (digitalRead(greenButton) == LOW) {
      greenButtonState = true;
      beginTime = millis();
      Serial.println(digitalRead(greenButton));
    }
  }

  // Check if the green button is pressed
  if (greenButtonState){
    while (cycleCount < 200) {
      cleanGauge();  // Run the clean gauge
      if (cycleCount == 200) {
        tone(piezoBuzzer, 2000);
        delay(1000);
        noTone(piezoBuzzer);
        cycleCount = 0; // Reset cycleCount
        greenButtonState = false; // Reset greenButtonState to false
        ESP.restart();
      }

    }
  }
}
